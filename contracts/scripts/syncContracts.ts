#!/usr/bin/env ts-node

/**
 * 从 contracts/deployments 生成前端 deployedContracts.ts
 * 用法: tsx scripts/syncContracts.ts
 */

import fs from "fs";
import path from "path";

const FRONTEND_DIR = path.join(__dirname, "../../apps/web/packages/nextjs");
const DEPLOYMENTS_DIR = path.join(__dirname, "../deployments");
const OUTPUT_FILE = path.join(FRONTEND_DIR, "contracts/deployedContracts.ts");

interface DeploymentFile {
  address: string;
  abi: any[];
  deployedOnBlock?: number;
}

async function main() {
  console.log("🔄 同步合约 ABI 到前端...\n");

  // 检查前端目录
  if (!fs.existsSync(FRONTEND_DIR)) {
    console.error(`❌ 前端目录不存在: ${FRONTEND_DIR}`);
    process.exit(1);
  }

  // 检查 deployments 目录
  if (!fs.existsSync(DEPLOYMENTS_DIR)) {
    console.error(`❌ Deployments 目录不存在: ${DEPLOYMENTS_DIR}`);
    console.log("   请先部署合约: npm run deploy:sepolia 或 npm run deploy:localhost");
    process.exit(1);
  }

  const contracts: Record<number, any> = {};

  // 读取所有网络的部署
  const networks = fs.readdirSync(DEPLOYMENTS_DIR).filter(name => {
    const stat = fs.statSync(path.join(DEPLOYMENTS_DIR, name));
    return stat.isDirectory() && name !== ".chainId";
  });

  console.log(`📂 发现 ${networks.length} 个网络: ${networks.join(", ")}\n`);

  for (const network of networks) {
    const networkPath = path.join(DEPLOYMENTS_DIR, network);

    // 读取 .chainId
    const chainIdFile = path.join(networkPath, ".chainId");
    if (!fs.existsSync(chainIdFile)) {
      console.log(`⚠️  跳过 ${network}: 缺少 .chainId`);
      continue;
    }

    const chainId = parseInt(fs.readFileSync(chainIdFile, "utf8").trim());
    console.log(`🔗 处理网络: ${network} (chainId: ${chainId})`);

    contracts[chainId] = {};

    // 读取该网络的所有合约
    const files = fs.readdirSync(networkPath).filter(f => f.endsWith(".json"));

    for (const file of files) {
      const contractName = path.basename(file, ".json");
      const filePath = path.join(networkPath, file);
      const deployment: DeploymentFile = JSON.parse(fs.readFileSync(filePath, "utf8"));

      contracts[chainId][contractName] = {
        address: deployment.address,
        abi: deployment.abi,
        inheritedFunctions: {},
        deployedOnBlock: deployment.deployedOnBlock || 0,
      };

      console.log(`   ✅ ${contractName}: ${deployment.address}`);
    }
  }

  // 生成 TypeScript 文件
  const tsContent = `/**
 * This file is autogenerated by syncContracts script.
 * You should not edit it manually or your changes might be overwritten.
 */
import { GenericContractsDeclaration } from "~~/utils/helper/contract";

const deployedContracts = ${JSON.stringify(contracts, null, 2)} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`;

  // 确保目录存在
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_FILE, tsContent);

  console.log(`\n✅ ABI 同步完成!`);
  console.log(`📝 输出文件: ${OUTPUT_FILE}`);
  console.log(`\n🎉 前端现在可以使用最新的合约接口了!`);
}

main().catch(err => {
  console.error("❌ 同步失败:", err);
  process.exit(1);
});
