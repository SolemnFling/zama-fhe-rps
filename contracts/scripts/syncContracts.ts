#!/usr/bin/env ts-node

/**
 * ä» contracts/deployments ç”Ÿæˆå‰ç«¯ deployedContracts.ts
 * ç”¨æ³•: tsx scripts/syncContracts.ts
 */

import fs from "fs";
import path from "path";

const FRONTEND_DIR = path.join(__dirname, "../../apps/web/packages/nextjs");
const DEPLOYMENTS_DIR = path.join(__dirname, "../deployments");
const OUTPUT_FILE = path.join(FRONTEND_DIR, "contracts/deployedContracts.ts");

interface DeploymentFile {
  address: string;
  abi: any[];
  deployedOnBlock?: number;
}

async function main() {
  console.log("ğŸ”„ åŒæ­¥åˆçº¦ ABI åˆ°å‰ç«¯...\n");

  // æ£€æŸ¥å‰ç«¯ç›®å½•
  if (!fs.existsSync(FRONTEND_DIR)) {
    console.error(`âŒ å‰ç«¯ç›®å½•ä¸å­˜åœ¨: ${FRONTEND_DIR}`);
    process.exit(1);
  }

  // æ£€æŸ¥ deployments ç›®å½•
  if (!fs.existsSync(DEPLOYMENTS_DIR)) {
    console.error(`âŒ Deployments ç›®å½•ä¸å­˜åœ¨: ${DEPLOYMENTS_DIR}`);
    console.log("   è¯·å…ˆéƒ¨ç½²åˆçº¦: npm run deploy:sepolia æˆ– npm run deploy:localhost");
    process.exit(1);
  }

  const contracts: Record<number, any> = {};

  // è¯»å–æ‰€æœ‰ç½‘ç»œçš„éƒ¨ç½²
  const networks = fs.readdirSync(DEPLOYMENTS_DIR).filter(name => {
    const stat = fs.statSync(path.join(DEPLOYMENTS_DIR, name));
    return stat.isDirectory() && name !== ".chainId";
  });

  console.log(`ğŸ“‚ å‘ç° ${networks.length} ä¸ªç½‘ç»œ: ${networks.join(", ")}\n`);

  for (const network of networks) {
    const networkPath = path.join(DEPLOYMENTS_DIR, network);

    // è¯»å– .chainId
    const chainIdFile = path.join(networkPath, ".chainId");
    if (!fs.existsSync(chainIdFile)) {
      console.log(`âš ï¸  è·³è¿‡ ${network}: ç¼ºå°‘ .chainId`);
      continue;
    }

    const chainId = parseInt(fs.readFileSync(chainIdFile, "utf8").trim());
    console.log(`ğŸ”— å¤„ç†ç½‘ç»œ: ${network} (chainId: ${chainId})`);

    contracts[chainId] = {};

    // è¯»å–è¯¥ç½‘ç»œçš„æ‰€æœ‰åˆçº¦
    const files = fs.readdirSync(networkPath).filter(f => f.endsWith(".json"));

    for (const file of files) {
      const contractName = path.basename(file, ".json");
      const filePath = path.join(networkPath, file);
      const deployment: DeploymentFile = JSON.parse(fs.readFileSync(filePath, "utf8"));

      contracts[chainId][contractName] = {
        address: deployment.address,
        abi: deployment.abi,
        inheritedFunctions: {},
        deployedOnBlock: deployment.deployedOnBlock || 0,
      };

      console.log(`   âœ… ${contractName}: ${deployment.address}`);
    }
  }

  // ç”Ÿæˆ TypeScript æ–‡ä»¶
  const tsContent = `/**
 * This file is autogenerated by syncContracts script.
 * You should not edit it manually or your changes might be overwritten.
 */
import { GenericContractsDeclaration } from "~~/utils/helper/contract";

const deployedContracts = ${JSON.stringify(contracts, null, 2)} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`;

  // ç¡®ä¿ç›®å½•å­˜åœ¨
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_FILE, tsContent);

  console.log(`\nâœ… ABI åŒæ­¥å®Œæˆ!`);
  console.log(`ğŸ“ è¾“å‡ºæ–‡ä»¶: ${OUTPUT_FILE}`);
  console.log(`\nğŸ‰ å‰ç«¯ç°åœ¨å¯ä»¥ä½¿ç”¨æœ€æ–°çš„åˆçº¦æ¥å£äº†!`);
}

main().catch(err => {
  console.error("âŒ åŒæ­¥å¤±è´¥:", err);
  process.exit(1);
});
